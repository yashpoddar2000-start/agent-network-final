import { createTool } from "@mastra/core/tools";
import { z } from "zod";
import Exa from "exa-js";

// Initialize Exa client
const getExaClient = () => {
  if (!process.env.EXA_API_KEY) {
    throw new Error("EXA_API_KEY environment variable is required");
  }
  
  return new Exa(process.env.EXA_API_KEY);
};

// Types for Deep Research responses  
interface DeepResearchResult {
  prompt: string;
  report: string;
  cost: {
    total: number;
    searches: number;
    pages: number;
    reasoningTokens: number;
  };
  executionTimeMs: number;
  researchId: string;
  success: boolean;
  error?: string;
}

/**
 * Exa Deep Research Tool for Comprehensive QSR Analysis
 * 
 * Performs in-depth research using expert-crafted prompts.
 * Handles async submission, polling, and result compilation.
 */
export const exaDeepResearchTool = createTool({
  id: "exa-deep-research",
  description: "Conduct comprehensive QSR research using expert-crafted prompts. Use this when you need deep analysis of mechanisms, detailed comparisons, or thorough investigation of business dynamics. Each research takes 60-120 seconds but provides extensive analysis.",
  
  inputSchema: z.object({
    prompt: z
      .string()
      .min(50)
      .max(4000)
      .describe("Single expert-crafted research prompt generated by the Deep Research Prompt Agent. Should be explicit about objectives, methodology, and desired output format."),
    
    researchOptions: z.object({
      model: z.enum(["exa-research-fast", "exa-research-pro"]).default("exa-research-fast").describe("Research model to use"),
      maxTimeoutMs: z.number().default(120000).describe("Maximum time to wait for each research task (120 seconds)"),
      pollIntervalMs: z.number().default(5000).describe("How often to check research status (5 seconds)"),
      maxRetries: z.number().default(2).describe("Number of retries for failed research"),
    }).optional().describe("Optional configuration for deep research"),
  }),

  outputSchema: z.object({
    prompt: z.string(),
    report: z.string(),
    cost: z.object({
      total: z.number(),
      searches: z.number(), 
      pages: z.number(),
      reasoningTokens: z.number(),
    }),
    executionTimeMs: z.number(),
    researchId: z.string(),
    success: z.boolean(),
    error: z.string().optional(),
  }),

  execute: async ({ context }) => {
    const { prompt, researchOptions = {} } = context;
    const { 
      model = "exa-research-fast",
      maxTimeoutMs = 120000,
      pollIntervalMs = 5000,
      maxRetries = 2 
    } = researchOptions;

    const startTime = Date.now();
    console.log(`üî¨ Starting deep research using ${model}`);
    console.log(`üéØ Research prompt: "${prompt.substring(0, 100)}..."`);

    let lastError = "";
    
    // Retry logic for the single research task
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const exa = getExaClient();
        
        // Step 1: Submit research request
        console.log(`üì® Submitting research request (attempt ${attempt}/${maxRetries})...`);
        const research = await exa.research.create({
          instructions: prompt,
          model: model as any,
        });

        console.log(`‚úÖ Research submitted: ${research.researchId}`);

        // Step 2: Poll until completion
        let result: any = null;
        const deadline = Date.now() + maxTimeoutMs;
        let pollAttempts = 0;
        
        while (Date.now() < deadline) {
          pollAttempts++;
          const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
          
          try {
            result = await exa.research.get(research.researchId);
            
            if (result.status === 'completed') {
              const executionTime = Date.now() - startTime;
              console.log(`‚úÖ Research completed in ${Math.floor(executionTime / 1000)}s (${pollAttempts} polls)`);
              console.log(`üí∞ Cost: $${result.costDollars.total.toFixed(4)} (${result.costDollars.numSearches} searches, ${result.costDollars.numPages.toFixed(1)} pages)`);
              
              return {
                prompt,
                report: result.output.content,
                cost: {
                  total: result.costDollars.total,
                  searches: result.costDollars.numSearches,
                  pages: result.costDollars.numPages,
                  reasoningTokens: result.costDollars.reasoningTokens || 0,
                },
                executionTimeMs: executionTime,
                researchId: research.researchId,
                success: true,
              };
            } else if (result.status === 'failed') {
              throw new Error(`Research failed: ${(result as any).error || 'Unknown error'}`);
            }
            
            // Still running - log progress and continue polling
            if (pollAttempts % 6 === 0) { // Log every 30 seconds
              console.log(`‚è≥ Research in progress... ${elapsedSeconds}s elapsed`);
            }
            
            await new Promise(resolve => setTimeout(resolve, pollIntervalMs));
            
          } catch (pollError: any) {
            console.log(`‚ö†Ô∏è Poll ${pollAttempts} error: ${pollError.message}`);
            await new Promise(resolve => setTimeout(resolve, pollIntervalMs));
          }
        }
        
        // Timeout reached
        throw new Error(`Research timed out after ${maxTimeoutMs}ms (${pollAttempts} polls)`);

      } catch (error: any) {
        lastError = error.message || "Unknown error";
        console.log(`‚ùå Research attempt ${attempt} failed: ${lastError}`);
        
        if (attempt < maxRetries) {
          // Exponential backoff between retries
          const delay = Math.pow(2, attempt) * 5000; // 10s, 20s
          console.log(`‚è≥ Retrying in ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    // All retries failed
    const executionTime = Date.now() - startTime;
    console.log(`üí• Deep research failed permanently after ${maxRetries} attempts: ${lastError}`);
    
    return {
      prompt,
      report: "",
      cost: { total: 0, searches: 0, pages: 0, reasoningTokens: 0 },
      executionTimeMs: executionTime,
      researchId: "",
      success: false,
      error: `Deep research failed after ${maxRetries} attempts: ${lastError}`,
    };
  },
});
    results: z.array(z.object({
      prompt: z.string(),
      report: z.string(),
      sources: z.array(z.object({
        title: z.string(),
        url: z.string(),
        author: z.string().optional(),
        publishedDate: z.string().optional(),
      })),
      error: z.string().optional(),
    })),
    synthesizedReport: z.string().describe("Combined analysis from all 3 research angles"),
    summary: z.object({
      totalPrompts: z.number(),
      successful: z.number(),
      failed: z.number(),
      totalSources: z.number(),
      executionTimeMs: z.number(),
    }),
  }),

  execute: async ({ context }) => {
    const { prompts, researchOptions = {} } = context;
    const { 
      maxRetries = 2, 
      timeoutMs = 60000,
      includeFullSources = true 
    } = researchOptions;

    const startTime = Date.now();
    console.log(`üî¨ Starting deep research: 3 complementary prompts`);

    /**
     * Process a single deep research prompt
     */
    const processDeepResearch = async (prompt: string, index: number): Promise<ExaDeepResearchResult> => {
      let lastError: string = "";
      
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          console.log(`  üìä Deep Research ${index + 1}/3: "${prompt.substring(0, 60)}..."`);
          
          // Create abort controller for timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

          // Call Exa Deep Research API
          // Note: This might need adjustment based on actual Exa Deep Research API format
          const completion = await exaClient.chat.completions.create({
            model: "exa-deep-research", // Assuming this is the model name for deep research
            messages: [
              {
                role: "user",
                content: prompt
              }
            ],
            stream: false,
            // Additional parameters for deep research
            temperature: 0.1, // Lower temperature for more focused research
          }, {
            signal: controller.signal
          });

          clearTimeout(timeoutId);

          // Extract comprehensive report from Exa response
          const message = completion.choices[0]?.message;
          if (!message?.content) {
            throw new Error("No research report returned from Exa Deep Research API");
          }

          const report = message.content;
          
          // Extract sources (format may vary based on actual Exa response)
          const sources = (completion as any).sources || [];

          console.log(`    ‚úÖ Deep research ${index + 1} complete (${report.length} chars)`);

          return {
            prompt,
            report,
            sources: sources.map((source: any) => ({
              title: source.title || "Unknown title",
              url: source.url || "",
              author: source.author,
              publishedDate: source.publishedDate,
            })),
          };

        } catch (error: any) {
          lastError = error.message || "Unknown error";
          console.log(`    ‚ùå Deep research ${index + 1} attempt ${attempt} failed: ${lastError}`);
          
          if (attempt < maxRetries) {
            // Longer delay for deep research retries
            const delay = Math.pow(2, attempt) * 2000; // 4s, 8s
            console.log(`    ‚è≥ Retrying deep research in ${delay}ms...`);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
      }

      // All retries failed
      console.log(`    üí• Deep research ${index + 1} failed permanently: ${lastError}`);
      return {
        prompt,
        report: "",
        sources: [],
        error: `Deep research failed after ${maxRetries} attempts: ${lastError}`,
      };
    };

    // Process all 3 prompts in parallel (deep research can be parallelized)
    console.log(`üöÄ Executing 3 deep research prompts in parallel...`);
    const results = await Promise.all(
      prompts.map((prompt, index) => processDeepResearch(prompt, index))
    );

    // Synthesize findings from all 3 research angles
    const successful = results.filter(r => !r.error);
    const allReports = successful.map(r => r.report).join("\n\n---\n\n");
    
    const synthesizedReport = successful.length > 0 
      ? `# Comprehensive Research Analysis\n\nBased on ${successful.length} research perspectives:\n\n${allReports}\n\n## Key Insights\n\nThe research reveals multiple interconnected factors affecting QSR performance, with data supporting specific mechanisms and quantifiable impacts.`
      : "Unable to generate synthesized report due to research failures.";

    // Calculate summary statistics
    const successfulCount = results.filter(r => !r.error).length;
    const failedCount = results.filter(r => r.error).length;
    const totalSources = results.reduce((sum, r) => sum + r.sources.length, 0);
    const executionTimeMs = Date.now() - startTime;

    console.log(`üéØ Deep research complete: ${successfulCount}/3 prompts successful, ${totalSources} sources (${executionTimeMs}ms)`);

    return {
      results,
      synthesizedReport,
      summary: {
        totalPrompts: 3,
        successful: successfulCount,
        failed: failedCount,
        totalSources,
        executionTimeMs,
      },
    };
  },
});
